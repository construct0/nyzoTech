<link rel="stylesheet" type="text/css" href="../style.css">

<h1>Joining the cycle</h1>

<p class="italic">
    This page was last reviewed at version 595. If the <span class="code">NodeManager</span> class has been updated
    since that version, this page may not reflect the latest behavior. Please review the
    <a href="/releaseNotes">release notes</a> to answer any questions.
</p>

<p>
    When a Nyzo verifier is started, it asks other verifiers for information on the current state of the blockchain.
    The location of verifiers are specified in the file
    <span class="filename">/var/lib/nyzo/production/trusted_entry_points</span>. A copy of this file is included in the
    Git repository, and it contains entries for <span class="verifier-name">verifier0.nyzo.co</span> through
    <span class="verifier-name">verifier9.nyzo.co</span>. Since the deactivation of the official Nyzo verifiers, these
    names point to multiple arbitrarily selected in-cycle verifiers.
</p>

<p>
    In order to be added to the <span class="code">NodeManager</span>, which is necessary for eventual consideration in
    the lottery, a verifier must be able to send node-join messages from an IP address <span class="italic">and receive
    node-join messages at the same address</span>. Additionally, a verifier must have exclusive control over that IP
    address. If multiple verifiers are broadcasting from an IP address, neither will be entered into the lottery.
</p>

<p>
    The following explanations describe the interactions between a single out-of-cycle verifier and a single in-cycle
    verifier. The end result of this process is addition to the lottery pool <span class="italic">of that in-cycle
    verifier</span>. Because this is a democratic system, and because the in-cycle verifier has only a single vote, the
    out-of-cycle verifier must repeat this process with the entire cycle in order to have an optimal probability of
    joining the cycle.
</p>

<p>
    The first step for a new verifier is requesting the cycle from trusted entry points. Due to code changes over time,
    the following code refers to the "mesh," and that term is incorrect. The "mesh" is an early term that described the
    set of all in-cycle and out-of-cycle nodes, and it has fallen out of favor in our development as the separation
    between the cycle and candidate (out-of-cycle) nodes has arisen. This code actually requests just the list of
    in-cycle nodes from the trusted entry points.
</p>

<p class="code-block">
    // Send mesh requests to all trusted entry points.<br>
    AtomicInteger numberOfMeshResponsesPending = new AtomicInteger(trustedEntryPoints.size());<br>
    for (TrustedEntryPoint entryPoint : trustedEntryPoints) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;fetchMesh(entryPoint, numberOfMeshResponsesPending);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;sendNodeJoinMessage(entryPoint);<br>
    }
</p>

<p>
    In the <span class="code">fetchMesh()</span> method, a node-join message is enqueued for every node in the response.
    So, as long as one trusted entry point is aware of a node, this node will send a join message to it.
</p>

<p class="code-block">
    private static void fetchMesh(TrustedEntryPoint entryPoint, AtomicInteger numberOfMeshResponsesPending) {<br>
    <br>
    <span class="pad">    </span>Message meshRequest = new Message(MessageType.MeshRequest15, null);<br>
    <span class="pad">    </span>Message.fetchTcp(entryPoint.getHost(), entryPoint.getPort(), meshRequest,
    new MessageCallback() {<br>
    <span class="pad">        </span>@Override<br>
    <span class="pad">        </span>public void responseReceived(Message message) {<br>
    <br>
    <span class="pad">            </span>// Enqueue node-join requests for all nodes in the response.<br>
    <span class="pad">            </span>MeshResponse response = (MeshResponse) message.getContent();<br>
    <span class="pad">            </span>for (Node node : response.getMesh()) {<br>
    <span class="pad">                </span>NodeManager.enqueueNodeJoinMessage(node.getIpAddress(),
    node.getPortTcp());<br>
    <span class="pad">            </span>}<br>
    <br>
    <span class="pad">            </span>numberOfMeshResponsesPending.decrementAndGet();<br>
    <span class="pad">        </span>}<br>
    <span class="pad">    </span>});<br>
    }
</p>

<p>
    The <span class="code">NodeManager.enqueueNodeJoinMessage()</span> method adds an entry to a map, keyed on the IP
    address of the receiver. This provides natural de-duplication when the same node is received in the
    <span class="code">MeshResponse</span> from multiple trusted entry points.
</p>

<p class="code-block">
    public static void enqueueNodeJoinMessage(byte[] ipAddress, int port) {<br>
    <br>
    <span class="pad">    </span>nodeJoinRequestQueue.put(ByteBuffer.wrap(ipAddress), port);<br>
    }
</p>

<p class="emphasis">
    This page is under active development.
</p>