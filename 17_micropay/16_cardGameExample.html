<link rel="stylesheet" type="text/css" href="../style.css">

<h1>Card game example</h1>

<p class="italic" style="margin-top: -1.3rem; font-size: 0.6rem;">
    Please read the description below the board for the current state of this page.
</p>

<style>
    .board {
        width: 100%;
        min-width: 300px;
        max-width: 600px;
        margin: auto;
        display: block;
    }
</style>

<canvas id="board" class="board" width="1600" height="1200">
</canvas>

<p class="emphasis">
    The playing board above currently displays a non-interactive, translucent, full deck of cards. Beneath the deck, a
    card table is displayed with markers positioned around the perimeter.
</p>

<p>
    This page will build upon the <a href="gameExample">tic-tac-toe game example</a> to create a multiplayer card game
    that is played on the Nyzo blockchain.
</p>

<p>
    This game will be an implementation of <span class="italic">Texas hold 'em</span> poker, which has some interesting
    challenges regarding game events and when they are revealed to various parties. Hole cards must be revealed only to
    the holder on deal, but they must be able to be confirmed by all players at the end of the game. The flop, turn, and
    river must all be revealed to all players as they are dealt. Additionally, no player should be able to determine the
    identity of a card earlier than any other player to whom it is supposed to be revealed.
</p>

<p class="italic">
    This page is in active development to demonstrate multiplayer gaming on the Nyzo blockchain.
</p>

<script>
    const club = 0;
    const diamond = 1;
    const heart = 2;
    const spade = 3;

    function configureBoardForCurrentState() {
        let board = document.getElementById('board');
        let context = board.getContext('2d');

        let width = board.width;
        let height = board.height;

        // Draw the background.
        let xc = width / 2;
        let yc = height / 2;
        let r0 = 0;
        let r1 = width / 2;
        let backgroundGradient = context.createRadialGradient(xc, yc, r0, xc, yc, r1);
        backgroundGradient.addColorStop(0, '#080');
        backgroundGradient.addColorStop(1, '#040');
        context.fillStyle = backgroundGradient;
        context.fillRect(0, 0, width, height);

        // Draw the table.
        const rectangleWidth = tableCenterRectangleWidth(width, height);
        const tableHeight = tableRectangleHeight(height);
        let tableGradient = context.createRadialGradient(xc, yc, r0, xc, yc, r1);
        tableGradient.addColorStop(0, '#110');
        tableGradient.addColorStop(1, '#252520');
        context.fillStyle = tableGradient;
        context.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        context.beginPath();
        context.moveTo(xc - rectangleWidth / 2, yc - tableHeight / 2);
        context.lineTo(xc + rectangleWidth / 2, yc - tableHeight / 2);
        context.arc(xc + rectangleWidth / 2, yc, tableHeight / 2, -Math.PI / 2, Math.PI / 2.0);
        context.lineTo(xc - rectangleWidth / 2, yc + tableHeight / 2);
        context.arc(xc - rectangleWidth / 2, yc, tableHeight / 2, Math.PI / 2, Math.PI * 1.5);
        context.fill();
        context.stroke();

        // Make an array for randomization to simulate shuffling.
        let cardIndices = [];
        for (let i = 0; i <= 52; i++) {
            cardIndices.push(i);
        }

        // Draw some dots around the table to figure out player positioning. The game will allow a variable number of
        // players. A simple function will provide position at the table where 0.0 is the left side of the table, 0.25
        // is the middle of the top, 0.5 is the right side of the table, and 0.75 is the middle of the bottom.
        for (let i = 0; i < 60; i++) {
            const position = positionForRatio(i / 60.0, width, height);
            context.beginPath();
            context.arc(position.x, position.y, height * 0.01, 0, Math.PI * 2.0);
            context.fillStyle = 'rgba(255, 255, 255, ' + ((i + 3) / 62.0) + ')';  // ascending alpha to visualize ordering
            context.fill();
        }

        // Draw the cards. Currently drawing the whole deck for development purposes.
        let cardWidth = width * 0.08;
        let cardHeight = cardWidth * 7.0 / 5.0;
        const cardsInDeck = 52;
        const cardsPerRow = 9;
        const numberOfRows = Math.ceil(cardsInDeck / cardsPerRow);
        let hGap = (width - cardWidth * cardsPerRow) / (cardsPerRow + 1.0);
        let vGap = (height - cardHeight * numberOfRows) / (numberOfRows + 1.0);
        context.globalAlpha = 0.3;
        for (let i = 0; i <= 52; i++) {
            const arrayIndex = Math.floor(Math.random() * cardIndices.length);
            const cardIndex = cardIndices[arrayIndex];
            cardIndices.splice(arrayIndex, 1);

            let column = i % cardsPerRow;
            let row = Math.floor(i / cardsPerRow);
            let x0 = (column + 1.0) * hGap + column * cardWidth;
            let y0 = (row + 1.0) * vGap + row * cardHeight;
            let rank = cardIndex == 52 ? '-' : ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q',
                'K'][cardIndex % 13];
            let suit = Math.floor(cardIndex / 13);
            drawCard(context, x0, y0, cardWidth, cardHeight, rank, suit);
        }
    }

    function positionForRatio(ratio, width, height) {
        const rectangleWidth = tableCenterRectangleWidth(width, height);
        const tableHeight = tableRectangleHeight(height);

        const arcLength = Math.PI * tableHeight / 4;
        const halfLength = arcLength * 2 + rectangleWidth;

        ratio = Math.max(0.0, Math.min(ratio, 1.0));
        const halfRatio = ratio <= 0.5 ? ratio * 2.0 : ratio * 2.0 - 1.0;
        const linearPosition = halfRatio * halfLength;
        console.log('linear position: ' + linearPosition);
        const isTop = ratio <= 0.5;
        let x, y;
        if (linearPosition < arcLength) {
            const angle = linearPosition / arcLength * Math.PI / 2;
            x = width / 2 - rectangleWidth / 2 - Math.cos(angle) * tableHeight / 2;
            y = height / 2 - Math.sin(angle) * tableHeight / 2;
        } else if (linearPosition < arcLength + rectangleWidth) {
            // This is the center, rectangular section of the table.
            x = width / 2 - rectangleWidth / 2 + linearPosition - arcLength;
            y = height / 2 - tableHeight * 0.5;
        } else {
            const angle = (linearPosition - arcLength - rectangleWidth) / arcLength * Math.PI / 2 - Math.PI / 2;
            x = width / 2 + rectangleWidth / 2 + Math.cos(angle) * tableHeight / 2;
            y = height / 2 + Math.sin(angle) * tableHeight / 2;
        }
        return {
            x: isTop ? x : width - x,
            y: isTop ? y : height - y
        };
    }

    function tableCenterRectangleWidth(width, height) {
        return rectangleWidth = width * 0.8 - height * 0.8;
    }

    function tableRectangleHeight(height) {
        return height * 0.8;
    }

    function drawCard(context, x0, y0, width, height, rank, suit) {
        // Draw the background.
        context.fillStyle = 'white';
        context.fillRect(x0, y0, width, height);

        // If the rank is '-', draw the back of the card.
        if (rank == '-') {
            context.fillStyle = '#500';
            const edge = width * 0.07;
            context.fillRect(x0 + edge, y0 + edge, width - edge * 2.0, height - edge * 2.0);
        } else {
            // Draw the rank.
            context.font = '900 ' + Math.ceil(width * 0.3) + 'px sans-serif';
            context.fontWeight = 'bold';
            context.fillStyle = suit == club || suit == spade ? 'black' : 'red';
            const xRank = x0 + width * 0.1;
            const yRank = y0 + height * 0.27;
            context.fillText(rank, xRank, yRank);

            // Draw the suit. The loop is a binary search to find the correct font size.
            let suitLetter = ['\u2663', '\u2666', '\u2665', '\u2660'][suit];
            const targetWidth = width * 0.6;
            let sizeLow = width * 0.5;
            let sizeHigh = width * 2.0;
            for (let i = 0; i < 10; i++) {
                let sizeMid = (sizeLow + sizeHigh) / 2.0;
                context.font = '900 ' + sizeMid + 'px sans-serif';
                let metrics = context.measureText(suitLetter);
                if (metrics.width > targetWidth) {
                    sizeHigh = sizeMid;
                } else {
                    sizeLow = sizeMid;
                }
            }
            let suitSize = (sizeLow + sizeHigh) / 2.0;
            context.font = '900 ' + ((sizeLow + sizeHigh) / 2.0) + 'px sans-serif';
            let suitWidth = context.measureText(suitLetter).width;
            let suitHeight = context.measureText('M').width;
            context.fillText(suitLetter, x0 + width * 0.5 - suitWidth * 0.5, y0 + height * 0.5 + suitHeight * 0.45);
        }
    }

    configureBoardForCurrentState();
</script>