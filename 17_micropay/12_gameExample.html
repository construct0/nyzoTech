<link rel="stylesheet" type="text/css" href="../style.css">

<h1>Game example</h1>

<p class="emphasis">
    This page requires version 6 or later of the Chrome extension to demonstrate full functionality.
</p>

<p>
    The previous example has been moved to the <a href="automaticTransactionExample">Micropay automatic transaction
    example</a> page. This page will build upon that example to demonstrate gaming with Nyzo.
</p>

<p>
    The API request for loading board state is sent and received, but transactions in the response are not yet
    processed. The board then activates, and a single play can be made.
</p>

<style>
    .board {
        display: table;
        margin: 1rem auto;
        border-radius: 0.4rem;
    }
    .board-invalid {
        opacity: 0.1;
        background-color:gray;
    }
    .board-win {
        background-color: rgba(128, 255, 128, 0.4);
    }
    .board > div {
        display: table-row;
    }
    .board > div > div {
        display: table-cell;
        text-align: center;
        border-right: 3px solid black;
        border-bottom: 3px solid black;
        width: 4.8rem;
    }
    .board > div > div > div {
        height: 0;
    }
    .board > div:last-child > div {
        border-bottom: none;
    }
    .board > div > div:last-child {
        border-right: none;
    }

    .sub-x {
        user-select: none;
    }
    .sub-o {
        position: relative;
        top: 0;
        user-select: none;
        padding-bottom: 100%;
    }
    .x .sub-x {
        visibility: visible;
    }
    .x .sub-o {
        visibility: hidden;
    }
    .o .sub-x {
        visibility: hidden;
    }
    .o .sub-o {
        visibility: visible;
    }
    .empty > div {
        visibility: hidden;
    }

    .form {
        text-align: center;
        border: 1px solid black;
        border-radius: 1rem;
        max-width: 30rem;
        margin: auto;
        padding: 1rem 1rem 0 1rem;
    }
    .form-input-container {
        width: 100%;
        margin-bottom: 1rem;
    }
    .form-label {
        margin-bottom: 0.2rem;
        text-align: left;
        width: 99%;
    }
    .form-input {
        width: 99%;
        padding: 0.3rem;
        box-sizing: border-box;
        border-radius: 0.5rem;
        border: 1px solid #ccc;
        outline: none;
    }
    .form-input-valid {
        background-color: #efe;
    }
    .form-input-invalid {
        background-color: #fee;
    }
    .form-input-disabled {
        background-color: #eee;
        color: #777;
        pointer-events: none;
        font-style: italic;
    }

    .action-button {
        border: 1px solid;
        border-radius: 0.5rem;
        padding: 0.5rem;
        text-decoration: none;
        color: white;
        cursor: pointer;
        user-select: none;
        border-color: #080;
        background-color: #484;
        display: inline-block;
    }
</style>

<div class="form">
    <div class="form-input-container">
        <div class="form-label">game ID (max. 23 characters)</div>
        <input class="form-input" id="game-identifier" oninput="gameIdentifierFieldChanged(this)">
    </div>

    <div class="form-input-container">
        <div class="form-label">opponent ID</div>
        <input class="form-input" id="opponent-identifier" oninput="opponentIdentifierFieldChanged(this)">
    </div>

    <div class="form-input-container">
        <div class="form-label">local ID</div>
        <input class="form-input form-input-disabled" id="local-identifier"
               value="will display ID configured in the extension" tabindex="-1">
    </div>
</div>

<div id="board" class="board">
    <div>
        <div id="cell-0" onclick="cellClick(this)">
            <div class="sub-x">
                <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                    <line x1="2" y1="2" x2="8" y2="8" stroke="black" stroke-linecap="round"></line>
                    <line x1="2" y1="8" x2="8" y2="2" stroke="black" stroke-linecap="round"></line>
                </svg>
            </div>
            <div class="sub-o">
                <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="5" cy="5" rx="3" ry="3" stroke="black" fill="none"></ellipse>
                </svg>
            </div>
        </div>
        <div id="cell-1" onclick="cellClick(this)"></div>
        <div id="cell-2" onclick="cellClick(this)"></div>
    </div>
    <div>
        <div id="cell-3" onclick="cellClick(this)"></div>
        <div id="cell-4" onclick="cellClick(this)"></div>
        <div id="cell-5" onclick="cellClick(this)"></div>
    </div>
    <div>
        <div id="cell-6" onclick="cellClick(this)"></div>
        <div id="cell-7" onclick="cellClick(this)"></div>
        <div id="cell-8" onclick="cellClick(this)"></div>
    </div>
</div>

<script src="sha256.js"></script>
<script src="nyzoString.js"></script>
<script src="micropayUtil.js"></script>
<script>

    // The states are stored on configuration key. Each configuration key represents a game. Currently, only one state
    // is stored for each game, but this will evolve to an array of states for each game.
    let states = [];

    // The board configuration key is the key that has been loaded via API request to the client. The board will only be
    // playable when this key is valid (not empty) and matches the key represented by the current field values. This
    // will not fully ensure consistency with the blockchain, but it is better than blindly allowing play on any game.
    let boardConfigurationKey = '';

    // This is used to schedule delayed API calls when fields are changing. This reduces resource usage and eliminates
    // some of the UX issues that might occur if API calls were sent immediately whenever a character is changed in any
    // of the fields used to configure the game.
    let maximumApiScheduleTimestamp = 0.0;

    const emptyBoard = '---------';
    const thisPlayerMarker = '0';
    const otherPlayerMarker = '1';

    function gameIdentifierValid(gameIdentifier) {
        let length = gameIdentifier.trim().length;
        return length > 0 && length <= 23;
    }

    function gameIdentifierFieldChanged(field) {
        localStorage.setItem('gameIdentifier', field.value.trim());
        field.className = gameIdentifierValid(field.value) ? 'form-input form-input-valid' :
            'form-input form-input-invalid';
        configureBoardForCurrentState();
        scheduleApiCallToFetchGameState();
    }

    function opponentIdentifierFieldChanged(field) {
        localStorage.setItem('opponentIdentifier', field.value.trim());
        field.className = isValidPublicIdentifier(field.value) ? 'form-input form-input-valid' :
            'form-input form-input-invalid';
        configureBoardForCurrentState();
        scheduleApiCallToFetchGameState();
    }

    function configurationKeyForCurrentFieldValues() {
        // The configuration key is a concatenation of local identifier, opponent identifier, and game identifier when
        // all three of those fields are valid. If any of the fields are invalid, the configuration key is the empty
        // string, which indicates an invalid configuration.
        let key = '';
        let localIdentifier = document.getElementById('local-identifier').value.trim();
        let opponentIdentifier = document.getElementById('opponent-identifier').value.trim();
        let gameIdentifier = document.getElementById('game-identifier').value.trim();

        if (isValidPublicIdentifier(localIdentifier) && isValidPublicIdentifier(opponentIdentifier) &&
            gameIdentifierValid(gameIdentifier)) {
            key = localIdentifier + ':' + opponentIdentifier + ':' + gameIdentifier;
        }

        return key;
    }

    function cellClick(cell) {
        // Determine the index. Only respond for an empty cell, and only respond when the game is valid and has been
        // loaded (the board key is consistent with the key representing the field values).
        let index = parseInt(cell.id.substring(5));
        if (boardConfigurationKey.length > 0 && boardConfigurationKey == configurationKeyForCurrentFieldValues()) {
            let state = states[boardConfigurationKey];
            if (state != null && state[index] == '-' && (state == emptyBoard || state[9] == otherPlayerMarker)) {
                // Place the appropriate letter at the appropriate position to build the next state.
                let play = count(state, 'X') > count(state, 'O') ? 'O' : 'X';
                let nextState = state.substring(0, index) + play + state.substring(index + 1, 9) + thisPlayerMarker;

                // If the next state is valid, replace the current state with the next state.
                if (isValidNextState(nextState, state)) {
                    states[boardConfigurationKey] = nextState;
                    configureBoardForCurrentState();
                }
            }
        }
    }

    function scheduleApiCallToFetchGameState() {
        console.log('scheduling API call to fetch game state');
        let apiScheduleTimestamp = Date.now();
        maximumApiScheduleTimestamp = apiScheduleTimestamp;
        setTimeout(sendApiCallToFetchGameState, 1000, apiScheduleTimestamp);
    }

    function sendApiCallToFetchGameState(apiScheduleTimestamp) {
        // Only perform the API call if this is the latest-scheduled call.
        if (apiScheduleTimestamp == maximumApiScheduleTimestamp) {
            const configurationKey = configurationKeyForCurrentFieldValues();
            if (configurationKey.length == 0) {
                console.log('setting boardConfigurationKey to invalid');
                boardConfigurationKey = '';
            } else {
                console.log('sending API call');
                // Get the values from the configuration key for consistency.
                let index0 = configurationKey.indexOf(':');
                let index1 = configurationKey.indexOf(':', index0 + 1);
                let localIdentifier = configurationKey.substring(0, index0);
                let opponentIdentifier = configurationKey.substring(index0 + 1, index1);
                let gameIdentifier = configurationKey.substring(index1 + 1);

                console.log('local identifier: ' + localIdentifier);
                console.log('opponent identifier: ' + opponentIdentifier);
                console.log('game identifier: ' + gameIdentifier);

                // Send the request to the client.
                const httpRequest = new XMLHttpRequest();
                httpRequest.onreadystatechange = function() {
                    if (this.readyState == 4) {  // 4 == "DONE"
                        if (this.status == 200) {
                            try {
                                console.log('received response');
                                const result = this.response.result;

                                // Process the existing moves from the received transactions, setting the current game
                                // state.

                                // If the game state is still null, set it to an empty board.
                                if (states[configurationKey] == null) {
                                    console.log('setting state to empty board');
                                    states[configurationKey] = emptyBoard;
                                }

                                // Store the board configuration key and configure the board.
                                boardConfigurationKey = configurationKey;
                                configureBoardForCurrentState();
                            } catch (error) { }
                        }
                    }
                };
                const url = 'https://client.nyzo.co/api/indexedSearch?accountIdentifier=' + localIdentifier +
                    '&senderDataPrefix=' + encodeURIComponent(gameIdentifier.substring(0, 8));
                console.log('url: ' + url);
                httpRequest.open('GET', url, true);
                httpRequest.responseType = 'json';
                httpRequest.send();
            }
        }
    }

    function populateBoard() {
        // Fill the board based on cell 0.
        let cell0 = document.getElementById('cell-0');
        for (let i = 1; i < 9; i++) {
           document.getElementById('cell-' + i).innerHTML = cell0.innerHTML;
        }

        // Load the game identifier and opponent identifier from local storage.
        document.getElementById('game-identifier').value = localStorage.getItem('gameIdentifier');
        document.getElementById('opponent-identifier').value = localStorage.getItem('opponentIdentifier');
    }

    function configureBoardForCurrentState() {
        let state = states[boardConfigurationKey];
        if (state == null) {
            state = emptyBoard;
        }

        for (let i = 0; i < 9; i++) {
            let div = document.getElementById('cell-' + i);
            if (state[i] == 'X') {
                div.className = 'x';
            } else if (state[i] == 'O') {
                div.className = 'o';
            } else {
                div.className = 'empty';
            }
        }

        // The board is unresponsive unless the board configuration key matches the fields and both are valid
        // (non-empty).
        if (boardConfigurationKey.length > 0 && boardConfigurationKey == configurationKeyForCurrentFieldValues()) {
            document.getElementById('board').className = isWinningState(state) ? 'board board-win' : 'board';
        } else {
            document.getElementById('board').className = 'board board-invalid';
        }
    }

    function isValidNextState(nextState, currentState) {
        // Only check further if the current state is not a winning state.
        let isValidNextState = false;
        if (!isWinningState(currentState)) {
            let currentXCount = count(currentState, 'X');
            let currentOCount = count(currentState, 'O');
            let nextXCount = count(nextState, 'X');
            let nextOCount = count(nextState, 'O');

            // The number of Xs should always be the same or one greater than the number of Os. Either the board should
            // be balanced and move to a +1X imbalance, or it should be a +1X imbalance and move to balanced.
            let toPlusOneX = (currentXCount == currentOCount && nextXCount == (currentXCount + 1) &&
                nextOCount == currentOCount);
            let toBalanced = (nextXCount == nextOCount && nextXCount == currentXCount &&
                nextOCount == (currentOCount + 1));
            if (toPlusOneX || toBalanced) {
                // Check the number of board differences. Exactly one is required.
                let numberOfDifferences = 0;
                for (let i = 0; i < 9; i++) {
                    if (currentState[i] != nextState[i]) {
                        numberOfDifferences++;
                    }
                }
                isValidNextState = numberOfDifferences == 1;
            }

            // If the state is currently determined to be valid, also check whether the correct ID (this or other) made
            // the move. This check only needs to be performed when the current X count is greater than 0, because
            // either player can make the first move. This is stored at index 9, with '0' signifying this player's move
            // and '1' signifying the other player's move.
            if (isValidNextState && currentXCount > 0) {
                if (currentState[9] == thisPlayerMarker) {
                    isValidNextState = nextState[9] == otherPlayerMarker;
                } else {
                    isValidNextState = nextState[9] == thisPlayerMarker;
                }
            }
        }

        return isValidNextState;
    }

    function isWinningState(state) {
        return (state[0] != '-' && (state[0] == state[1] && state[1] == state[2])) ||   // top
            (state[0] != '-' && (state[0] == state[3] && state[3] == state[6])) ||      // left
            (state[2] != '-' && (state[2] == state[5] && state[5] == state[8])) ||      // right
            (state[6] != '-' && (state[6] == state[7] && state[7] == state[8])) ||      // bottom
            (state[0] != '-' && (state[0] == state[4] && state[4] == state[8])) ||      // left diagonal
            (state[2] != '-' && (state[2] == state[4] && state[4] == state[6])) ||      // right diagonal
            (state[3] != '-' && (state[3] == state[4] && state[4] == state[5])) ||      // middle horizontal
            (state[1] != '-' && (state[1] == state[4] && state[4] == state[7]));        // middle vertical
    }

    function isValidState(state) {
        // The number of Xs and Os must be the same, or the number of Xs should be one greater than the number of Os.
        let xCount = count(state, 'X');
        let oCount = count(state, 'O');

        return xCount == oCount || xCount == (oCount + 1);
    }

    function count(state, character) {
        let count = 0;
        for (let i = 0; i < 9; i++) {
            if (state[i] == character) {
                count++;
            }
        }

        return count;
    }

    // Add a listener for the public identifier from the extension.
    document.addEventListener('nyzo-public-identifier-configured', function(event) {
        document.getElementById('local-identifier').value = event.detail;
        configureBoardForCurrentState();
        scheduleApiCallToFetchGameState();
    });

    populateBoard();
    configureBoardForCurrentState();

    // Trigger initial field updates.
    gameIdentifierFieldChanged(document.getElementById('game-identifier'));
    opponentIdentifierFieldChanged(document.getElementById('opponent-identifier'));
</script>

<p class="italic">
    This page is under active development as a demonstration of the process for building applications on Nyzo.
</p>