<link rel="stylesheet" type="text/css" href="../style.css">

<h1>Graffiti example</h1>

<style>
    .canvas-container {
        display: flex;
        align-items: flex-start;
        justify-content: center;
        gap: 10px;
    }

    .wall {
        border: 1px solid black;
        min-width: 240px;
        max-width: 720px;
        image-rendering: pixelated;
        width: 75%;
    }

    .thumbnail {
        border: 1px solid black;
        min-width: 48px;
        max-width: 144px;
        width: 15%;
    }

    .color-selector-container {
        margin: 1rem 0;
        text-align: center;
    }

    .color-selector-border {
        display: inline-block;
        padding: 3px;
    }

    .color-selector-border-unselected {
        background-color: white;
        border: 2px solid white;
    }

    .color-selector-border-selected {
        background-color: #ccc;
        border: 2px solid black;
        border-radius: 4px;
    }

    .color-selector {
        border: 1px solid black;
        width: 40px;
        height: 40px;
    }
</style>

<div class="canvas-container">
    <canvas id="wall" class="wall" width="10" height="10">
    </canvas>

    <canvas id="thumbnail" class="thumbnail" width="10" height="10">
    </canvas>
</div>

<div id="color-selector-container" class="color-selector-container">
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #000000;"></div>
    </div>
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #0000AA;"></div>
    </div>
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #00AA00;"></div>
    </div>
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #00AAAA;"></div>
    </div>
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #AA0000;"></div>
    </div>
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #AA00AA;"></div>
    </div>
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #AA5500;"></div>
    </div>
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #AAAAAA;"></div>
    </div>
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #555555;"></div>
    </div>
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #5555FF;"></div>
    </div>
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #55FF55;"></div>
    </div>
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #55FFFF;"></div>
    </div>
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #FF5555;"></div>
    </div>
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #FF55FF;"></div>
    </div>
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #FFFF55;"></div>
    </div>
    <div class="color-selector-border" onclick="colorSelectorClicked(this);">
        <div class="color-selector" style="background-color: #FFFFFF;"></div>
    </div>
</div>

<p class="emphasis">
    This page currently allows simple drawing on the wall, but nothing is sent to the blockchain.
</p>

<p>
    This page will have a virtual graffiti wall on which users can draw using automatic transactions. The wall will have
    a resolution of 240 pixels by 180 pixels and use the CGA 16-color palette. For testing, the wall is currently 10
    pixels by 10 pixels.
</p>

<p class="italic">
    This page is in active development to demonstrate a realtime multiuser application on the Nyzo blockchain.
</p>

<script>
    // Get the contexts.
    const wall = document.getElementById('wall');
    const wallContext = wall.getContext('2d');
    const thumbnail = document.getElementById('thumbnail');
    const thumbnailContext = thumbnail.getContext('2d');

    // These are the variables that store the wall state.
    const width = wall.width;
    const height = wall.height;
    let block = -1;
    let blockchainImageData = null;
    let localImageData = null;
    let amounts = null;

    // Get the colors from the color selectors.
    const colors = [];
    for (let i = 0; i < 16; i++) {
        colors[i] = document.getElementById('color-selector-container').children[i].children[0].style.backgroundColor;
    }

    // Initialize the color selection.
    let selectedColorIndex = localStorage.getItem('selected-color-index');
    if (selectedColorIndex == null) {
        selectedColorIndex = 0;
    }
    colorSelectorClicked(document.getElementById('color-selector-container').children[selectedColorIndex]);

    // Load the initial state of the wall.
    loadWall();

    // Add the listeners for drawing.
    wall.addEventListener('mousedown', function(event) {
        setPixelForEvent(event);
    });
    wall.addEventListener('mousemove', function(event) {
        setPixelForEvent(event);
    });
    wall.addEventListener('mouseleave', function(event) {
        setPixelForEvent(event);
    });

    let previousX = -1000;
    let previousY = -1000;
    function setPixelForEvent(event) {
        if (event.buttons == 1) {
            const bounds = wall.getBoundingClientRect();
            const x = Math.floor(event.offsetX * wall.width / bounds.width);
            const y = Math.floor(event.offsetY * wall.height / bounds.height);
            wallContext.fillRect(x, y, 1, 1);
            thumbnailContext.fillRect(x, y, 1, 1);

            if (previousX > -1000 && previousY > -1000) {
                if (Math.abs(x - previousX) > Math.abs(y - previousY)) {
                    // Figure out the iteration direction.
                    let xStart, xEnd, yStart, yEnd;
                    if (x < previousX) {
                        xStart = x;
                        xEnd = previousX;
                        yStart = y;
                        yEnd = previousY;
                    } else {
                        xStart = previousX;
                        xEnd = x;
                        yStart = previousY;
                        yEnd = y;
                    }

                    // Interpolate.
                    for (let xc = xStart; xc <= xEnd; xc++) {
                        const yc = Math.round(yStart + (xc - xStart) * (yEnd - yStart) / (xEnd - xStart));
                        wallContext.fillRect(xc, yc, 1, 1);
                        thumbnailContext.fillRect(xc, yc, 1, 1);
                    }
                } else {
                    // Figure out the iteration direction.
                    let xStart, xEnd, yStart, yEnd;
                    if (y < previousY) {
                        xStart = x;
                        xEnd = previousX;
                        yStart = y;
                        yEnd = previousY;
                    } else {
                        xStart = previousX;
                        xEnd = x;
                        yStart = previousY;
                        yEnd = y;
                    }

                    // Interpolate.
                    for (let yc = yStart; yc <= yEnd; yc++) {
                        const xc = Math.round(xStart + (yc - yStart) * (xEnd - xStart) / (yEnd - yStart));
                        wallContext.fillRect(xc, yc, 1, 1);
                        thumbnailContext.fillRect(xc, yc, 1, 1);
                    }
                }
            }

            previousX = x;
            previousY = y;
        } else {
            previousX = -1000;
            previousY = -1000;
        }
    }

    function colorSelectorClicked(div) {
        const container = document.getElementById('color-selector-container');
        let color = '';
        for (let i = 0; i < container.children.length; i++) {
            const child = container.children[i];
            if (child == div) {
                child.classList.add('color-selector-border-selected');
                child.classList.remove('color-selector-border-unselected');
                color = child.children[0].style.backgroundColor;

                localStorage.setItem('selected-color-index', i);
            } else {
                child.classList.add('color-selector-border-unselected');
                child.classList.remove('color-selector-border-selected');
            }
        }

        // Set the drawing color.
        wallContext.fillStyle = color;
        thumbnailContext.fillStyle = color;
    }

    function loadWall() {

        // Bootstrap the board from relay0.nyzo.co. This is a digest of the state at a specific block, and the client
        // will be used to provide all state changes since that block.

        const url = 'https://relay0.nyzo.co/graffiti';
        fetch(url)
                .then(response => response.status == 200 && response.json())
                .then(data => {
                    if (data.block > 0 && data.image.length > 0 && data.amounts.length > 0) {
                        // Store the block and image data.
                        block = data.block;
                        blockchainImageData = data.image;
                        localImageData = [...blockchainImageData];
                        amounts = data.amounts;
                        console.log('retrieved bootstrap data');

                        // Draw the canvas based on the image data.
                        drawCanvasFromImageData();
                    } else {
                        // Handle the error.
                        console.log('bootstrap data is not in expected format');
                    }

                })
                .catch(function (error) {
                    console.log('error: ' + error);
                });
    }

    function drawCanvasFromImageData() {

        for (let i = 0; i < localImageData.length; i++) {
            const xc = i % wall.width;
            const yc = Math.floor(i / wall.width);

            const color = colors[localImageData[i]];
            if (color != null) {
                wallContext.fillStyle = color;
                thumbnailContext.fillStyle = color;
                wallContext.fillRect(xc, yc, 1, 1);
                thumbnailContext.fillRect(xc, yc, 1, 1);
            }
        }
    }

    function generateTransactions() {

        // This function will generate transactions to represent drawing commands.

        // The canvas is 240 pixels wide by 180 pixels tall, which is 43,200 pixels. Referenced linearly, this allows
        // for each pixel to be addressed with 16 bits (2 bytes). The color is another 4 bits (one half of a byte). So,
        // with a reasonable packing, 12 pixels can be set with each transaction, using 30 of 32 bytes of the
        // sender-data field.
    }

</script>